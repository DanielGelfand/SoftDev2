# -*- coding: utf-8 -*-
"""PQUEUE

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1RYCJdNPzNwgXxbNAIj2Dq-aLCU9f7ZtL
"""

class Pqueue:

    def OrdinaryComparison(a,b):
        #print("a",a)
        #print("b",b)
        if a < b: return -1
        if a == b: return 0
        return 1

    def __init__(self, comparator = OrdinaryComparison):
        self.cmpfunc = comparator
        self.queue = [None]
        self.end = None

    def swap(self,index1,index2):
        temp = self.queue[index1]
        self.queue[index1]=self.queue[index2]
        self.queue[index2]=temp

    def push(self,data):

        # if nothing in the 1st slot
        if self.end == None or self.end == 0:
            self.queue.append(data)
            self.end = 1
            return

        else:
            self.queue.append(data)
            self.end += 1
            #print(self.queue)

            # Bubble up


            dataIndex = self.end
            #print("dataIndex",dataIndex)
            parentIndex = int(dataIndex/2)
            #print("parentIndex",parentIndex)
            #print(self.queue[parentIndex])
            #print(self.queue[1])

            # Initial check if data appended is in wrong place. 1 if True
            wrongPlace = self.cmpfunc( self.queue[parentIndex] , data)


            # while the data is smaller than the parent
            while wrongPlace == 1:

              # swap parent and child
              self.swap(dataIndex,parentIndex)
              dataIndex = parentIndex
              parentIndex = int(dataIndex/2)

              if (parentIndex > 0 ):
                wrongPlace = self.cmpfunc( self.queue[parentIndex] , data)
              else:
                return



    def peek(self):
        if not self.queue[1] == None:
          return self.queue[1]
        return None

    def pop(self):
        # if queue has no data
        if self.end == 0:
            return None
        # if only 1 elem
        elif self.end == 1:
            self.end -= 1
            return self.queue.pop(1)

        else:
            return self.bubbleDown()

    def bubbleDown(self):

      #Inital
      result = self.queue[1]

      trackIndex = 1
      result = self.queue[1]
      self.queue[1] = self.queue[self.end]
      self.queue.pop(self.end)
      self.end -= 1

      trackNode = self.queue[trackIndex]
      leftIndex = 2
      rightIndex = 3

      #**********CHOOSING WHICH CHILD TO SWAP WITH************************

      #if left smaller than right

      if (leftIndex > self.end):
        return result

      elif (rightIndex > self.end and leftIndex <= self.end):
        childIndex = leftIndex

      elif self.cmpfunc( self.queue[leftIndex] , self.queue[rightIndex] ) == -1:
        childIndex = leftIndex
      elif self.cmpfunc( self.queue[leftIndex] , self.queue[rightIndex] ) == 0:
        childIndex = leftIndex
      else:
        childIndex = rightIndex
      #********************************************************************

      # wrongPlace = 1 if trackNode > node at childIndex
      wrongPlace = self.cmpfunc( trackNode, self.queue[childIndex] )

      #while node being tracked is in the wrong place
      while wrongPlace == 1:

        self.swap( trackIndex , childIndex )

        trackIndex = childIndex
        leftIndex = trackIndex * 2
        rightIndex = trackIndex * 2 + 1


        if (leftIndex >= self.end):
          break

        if self.cmpfunc( self.queue[leftIndex] , self.queue[rightIndex] ) == -1:
          childIndex = leftIndex
        elif self.cmpfunc( self.queue[leftIndex] , self.queue[rightIndex] ) == 0:
          childIndex = leftIndex
        else:
          childIndex = rightIndex

        wrongPlace = self.cmpfunc( trackNode, self.queue[childIndex] )
      return result

    def tolist(self):
        lout = []
        if self.end == None:
            return lout
        for x in range(self.end):
            lout.append( self.pop() )
        return lout

fred = Pqueue()
#print(fred.cmpfunction(1,2))
fred.push(1)
fred.push(3)
fred.push(0)
fred.push(2)
fred.push(8)
fred.push(9)
fred.push(4)

print( "Peek" , fred.peek() )

print ( fred.pop() )
print ( fred.pop() )

print( fred.queue )
print( fred.tolist() )

print("-------------")




bob = Pqueue()
bob.push(2)
bob.push(3)
bob.push(4)
bob.push(1)
print("end correct?", bob.end)
print("Peek" ,  bob.peek() )
print( bob.queue )
print( bob.pop() )

print("Peek" ,  bob.peek() )
print( bob.queue )
print( bob.pop() )

print( bob.queue )
print( bob.pop() )

print( bob.queue )
print( bob.pop() )

print( bob.queue )
print ( bob.pop() )

bob.push(8)
print( "bob" , bob.queue )



ed = Pqueue()
ed.push(1)
ed.push(2)
ed.push(3)
ed.pop()
print("ed rn",ed.queue)
ed.push(1)
print("ed",ed.tolist())


jul = Pqueue()
jul.push(5)
jul.push(3)
jul.push(2)
jul.push(8)
print( "jul" ,  jul.queue )
print( "popped" , jul.pop() )
print( "jul" ,  jul.queue )
print( jul.tolist() )
print( "jul" ,  jul.queue )
jul.push(7)
jul.push(9)
jul.push(20)
jul.push(26)
jul.push(4)
jul.push(6)
print("peek",jul.peek())
print( jul.tolist() )
print("peek",jul.peek())
#print(bob.tolist())